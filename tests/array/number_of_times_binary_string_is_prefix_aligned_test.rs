use rust_practice::array::number_of_times_binary_string_is_prefix_aligned::Solution;

#[test]
fn num_times_all_blue() {
    // 示例 1：
    // 输入：flips = [3,2,4,1,5]
    // 输出：2
    // 解释：二进制字符串最开始是 "00000" 。
    // 执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。
    // 执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。
    // 执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。
    // 执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。
    // 执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。
    // 在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。
    let flips = vec![3, 2, 4, 1, 5];
    assert_eq!(Solution::num_times_all_blue(flips), 2);

    // 示例 2：
    // 输入：flips = [4,1,2,3]
    // 输出：1
    // 解释：二进制字符串最开始是 "0000" 。
    // 执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。
    // 执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。
    // 执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。
    // 执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。
    // 在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。
    let flips = vec![4, 1, 2, 3];
    assert_eq!(Solution::num_times_all_blue(flips), 1);
}
